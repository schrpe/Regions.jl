var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Regions","category":"page"},{"location":"#Regions","page":"Home","title":"Regions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Regions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Regions.jl defines a set of types and functions that model a discrete 2-dimensional region concept. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Example of a region)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In order to use the types and functions defined in the Regions package, you must first install it with the package manager and then make it known to your module:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> using Pkg.add(path=\"D:/!julia/Regions\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Regions","category":"page"},{"location":"","page":"Home","title":"Home","text":"Regions can be used for various purposes in machine vision and image processing. Since they provide an efficient run-length encoding of binary images, they avoid the need to touch every pixel when doing binary morphology and thus enable substantial speedup of such operations. Regions are also the basis for binary blob analysis, where the calculation of shape-based features is also substantially accelerated because of the run-length encoding. Finally, regions can be used as the domain of image processing functions.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A region can be seen as a set of discrete coordinates in the cartesian plane. In fact, one of the main motivations for the region concept was to model a set of pixel locations for image processing purposes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A region is represented with a sorted list of horizontal runs. Runs themselves are represented with a horizontal columns range and a vertical row coordinate.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Region and runs)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here is how this region can be created using the Julia REPL (assuming the origin (0, 0) is at the upper left):","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Region([Run(0, 1:4), Run(1, 0:5), Run(2, 1:2), Run(2, 4:6), Run(3, 1:2), Run(3, 5:5), Run(4, 1:2), Run(4, 4:5), Run(5, 2:4)])\nRegion(Run[Run(0, 1:4), Run(1, 0:5), Run(2, 1:2), Run(2, 4:6), Run(3, 1:2), Run(3, 5:5), Run(4, 1:2), Run(4, 4:5), Run(5, 2:4)], false)","category":"page"},{"location":"#Range","page":"Home","title":"Range","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The most basic building block of a region is a range. The UnitRange{Int64} is a suitable type and can be written like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> 0:99\n0:99\n\njulia> (0:99).start\n0\n\njulia> (0:99).stop\n99\n\njulia> length(0:99)\n100\n\njulia> length(-50:50)\n101","category":"page"},{"location":"","page":"Home","title":"Home","text":"A range where the stop is less than the start is considered empty.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> isempty(0:0)\nfalse\n\njulia> isempty(1:0)\ntrue","category":"page"},{"location":"","page":"Home","title":"Home","text":"The natural sort order of ranges is to sort them by their start.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> 0:100 < 1:101\ntrue\n\njulia> 0:1 < 1:100\ntrue\n\njulia> 0:50 < 0:100\ntrue\n\njulia> isless(0:100, 1:101)\ntrue","category":"page"},{"location":"","page":"Home","title":"Home","text":"Inversion mirrors a range at the origin.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> invert(0:100)\n-100:0\n\njulia> invert(invert(5:10))\n5:10","category":"page"},{"location":"","page":"Home","title":"Home","text":"Translation moves a range by an offset.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> translate(0:100, 50)\n50:150\n\njulia> (10:20) + 30\n40:50\n\njulia> 10 + (20:30)\n30:40\n\njulia> (50:100) - 10\n40:90","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can check whether a value is contained in a range.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> contains(10:20, 10)\ntrue\n\njulia> contains(10:20, 15)\ntrue\n\njulia> contains(10:20, 20)\ntrue\n\njulia> contains(10:20, 9)\nfalse\n\njulia> 14 ∈ 10:20\ntrue","category":"page"},{"location":"","page":"Home","title":"Home","text":"Two ranges can overlap or touch.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> isoverlapping(10:20, 5:25)\ntrue\n\njulia> isoverlapping(0:0, 1:1)\nfalse\n\njulia> istouching(0:0, 1:1)\ntrue\n\njulia> istouching(0:0, 2:2)\nfalse","category":"page"},{"location":"#Run","page":"Home","title":"Run","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A run combines a vertical row coordinate with a range of horizontal columns coordinates.","category":"page"},{"location":"","page":"Home","title":"Home","text":"An empty run is a run whose columns range is empty.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> isempty(Run(0, 0:-1))\ntrue\n\njulia> isempty(Run(0, 0:100))\nfalse","category":"page"},{"location":"","page":"Home","title":"Home","text":"The natural sort order of runs is to sort them by their row, then by their columns range.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Run(0, 0:100) < Run(1, 0:100)\ntrue\n\njulia> Run(0, 0:100) < Run(0, 1:101)\ntrue","category":"page"},{"location":"","page":"Home","title":"Home","text":"Inversion mirrors a run at the origin.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> invert(Run(10, 50:100))\nRun(-10, -100:-50)\n\njulia> invert(invert(Run(1, 5:10)))\nRun(1, 5:10)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Translation moves a run by horizontal and vertical offsets.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> translate(Run(0, 0:100), 10, 20)\nRun(20, 10:110)\n\njulia> Run(0, 10:20) + [30, 40]\nRun(40, 40:50)\n\njulia> Run(0, 10:20) - [30, 40]\nRun(-40, -20:-10)","category":"page"},{"location":"#Region","page":"Home","title":"Region","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A region is a subset of the discrete two-dimensional space. It represents a set (in the sense of mathematical set theory) of discrete coordinates. A region may be finite or infinite. A region may not be connected and it may contain holes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Regions are an essential concept in computer vision and are useful in many respects.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Regions are not necessarily related to images; they can exist independently and without images. In addition, the coordinate space is not confined to the bounds of an image, and regions can extend into the quadrants with negative coordinates in the two-dimensional space.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Reference","page":"Home","title":"Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Regions]","category":"page"},{"location":"#Regions.Regions","page":"Home","title":"Regions.Regions","text":"Regions\n\nMain module for Regions.jl - a set of types that model a discrete  2-dimensional region concept.\n\nExports\n\nRun   \nRegion\n\n\n\n\n\n","category":"module"},{"location":"#Regions.Region","page":"Home","title":"Regions.Region","text":"Region\n\nA region is a discrete set of coordinates in two-dimensional euclidean space.\n\n\n\n\n\n","category":"type"},{"location":"#Regions.Run","page":"Home","title":"Regions.Run","text":"Run\n\nA run is a (possibly partial) set of consecutive coordinates within a row of a  region. It consists of a discrete row coordinate (of type Signed) and a range  of discrete column coordinates (of type UnitRange{Int64}).\n\nRuns specify a sort order: one run is smaller than the other if it starts before the other run modeling the coordinates from left to right and top to  bottom.\n\n\n\n\n\n","category":"type"},{"location":"#Base.:==-Tuple{Region, Region}","page":"Home","title":"Base.:==","text":"==(a::Region, b::Region)\n\nEquality operator for two regions. Two regions are equal, if both their runs and their  complement flags are equal.\n\n\n\n\n\n","category":"method"},{"location":"#Base.contains-Tuple{Region, Integer, Integer}","page":"Home","title":"Base.contains","text":"contains(r::Region, x::Integer, y::Integer)\ncontains(r::Region, a::Array{Int64, 1})\n\nTest if region r contains position (x, y).\n\n\n\n\n\n","category":"method"},{"location":"#Base.contains-Tuple{Run, Integer, Integer}","page":"Home","title":"Base.contains","text":"contains(r::Run, x::Integer, y::Integer)\ncontains(r::Run, a::Array{Int64, 1})\n\nTest if run r contains position (x, y).\n\n\n\n\n\n","category":"method"},{"location":"#Base.contains-Tuple{UnitRange{Int64}, Integer}","page":"Home","title":"Base.contains","text":"contains(x::UnitRange{Int64}, y::Integer)\n\nTest if range x contains value x.\n\nIn addition to the contains method, you can also use the ∈ operator.\n\njulia> using Regions\n\njulia> contains(0:10, 5)\ntrue\n\njulia> contains(0:10, 15)\nfalse\n\njulia> 0 ∈ 0:10\ntrue\n\njulia> 100 ∈ 0:10\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.copy-Tuple{Region}","page":"Home","title":"Base.copy","text":"copy(x::Region)\n\nCreate a copy of a region.    \n\n\n\n\n\n","category":"method"},{"location":"#Base.isempty-Tuple{Run}","page":"Home","title":"Base.isempty","text":"isempty(x::Run)\n\nDiscover whether the run is empty.\n\njulia> using Regions\n\njulia> isempty(Run(1, 1:10))\nfalse\n\njulia> isempty(Run(2, 1:1))\nfalse\n\njulia> isempty(Run(3, 1:0))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Base.isless-Tuple{Run, Run}","page":"Home","title":"Base.isless","text":"isless(x::Run, y::Run)\n\nCompare two runs according to their natural sort order. First, their rows are compared, and if they are equal, their column ranges are compared.\n\njulia> using Regions\n\njulia> isless(Run(0, 1:10), Run(1, 0:10))\ntrue\n\njulia> isless(Run(1, 1:10), Run(1, 2:10))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Base.union-Tuple{Region, Region}","page":"Home","title":"Base.union","text":"union(a::Region, b::Region)\n\nCalculates the union of two regions. This function supports complement regions and uses  DeMorgan's rules to eliminate the complement.    \n\n\n\n\n\n","category":"method"},{"location":"#Base.union-Tuple{Vector{Run}, Vector{Run}}","page":"Home","title":"Base.union","text":"union(a::Array{Run,1}, b::Array{Run,1})\n\nCalculates the union of two sorted arrays of runs. The function assumes that the runs are sorted but does not check this.\n\n\n\n\n\n","category":"method"},{"location":"#Regions.closing-Tuple{Region, Region}","page":"Home","title":"Regions.closing","text":"closing(a::Region, b::Region)\n\nClosing is implemented by a dilation followed by a minkowski subtraction. The structuring  element should be a region that is centered on the origin. Gaps and holes smaller than the structuring element are closed and the region boundaries are smoothed.\n\n\n\n\n\n","category":"method"},{"location":"#Regions.complement-Tuple{Region}","page":"Home","title":"Regions.complement","text":"complement(x::Region)\n\nCalculates the set-theoretic complement of a region.   \n\n\n\n\n\n","category":"method"},{"location":"#Regions.difference-Tuple{Region, Region}","page":"Home","title":"Regions.difference","text":"difference(a::Region, b::Region)\n\nCalculates the union of two regions. This function supports complement regions and uses  DeMorgan's rules to eliminate the complement.\n\n\n\n\n\n","category":"method"},{"location":"#Regions.difference-Tuple{Vector{Run}, Vector{Run}}","page":"Home","title":"Regions.difference","text":"difference(a::Array{Run,1}, b::Array{Run,1})\n\nCalculates the difference of two sorted arrays of runs. The function assumes that the runs are sorted but does not check this.\n\n\n\n\n\n","category":"method"},{"location":"#Regions.dilation-Tuple{Region, Region}","page":"Home","title":"Regions.dilation","text":"dilation(a::Region, b::Region)\n\nDilation of a with structuring element b. Both the region a and the structuring element b are regions. The structuring element should be a region that is centered on the origin. This function partially supports complement regions  and uses DeMorgan's rules to eliminate the complement.    \n\n\n\n\n\n","category":"method"},{"location":"#Regions.dilation-Tuple{Vector{Run}, Vector{Run}}","page":"Home","title":"Regions.dilation","text":"dilation(a::Array{Run,1}, b::Array{Run,1})\n\nDilation of a with structuring element b. The function assumes that the runs are sorted but does not check this.\n\n\n\n\n\n","category":"method"},{"location":"#Regions.erosion-Tuple{Region, Region}","page":"Home","title":"Regions.erosion","text":"erosion(a::Region, b::Region)\n\nErosion of a with structuring element b. Both the region a and the structuring element b are regions. The structuring element should be a region that is centered on the origin. This function partially supports complement regions  and uses DeMorgan's rules to eliminate the complement.    \n\n\n\n\n\n","category":"method"},{"location":"#Regions.erosion-Tuple{Vector{Run}, Vector{Run}}","page":"Home","title":"Regions.erosion","text":"erosion(a::Array{Run,1}, b::Array{Run,1})\n\nErosion of a with structuring element b. The function assumes that the runs are sorted but does not check this.\n\n\n\n\n\n","category":"method"},{"location":"#Regions.intersection-Tuple{Region, Region}","page":"Home","title":"Regions.intersection","text":"intersection(a::Region, b::Region)\n\nCalculates the intersection of two regions. This function supports complement regions and uses  DeMorgan's rules to eliminate the complement.    \n\n\n\n\n\n","category":"method"},{"location":"#Regions.intersection-Tuple{Vector{Run}, Vector{Run}}","page":"Home","title":"Regions.intersection","text":"intersection(a::Array{Run,1}, b::Array{Run,1})\n\nCalculates the intersection of two sorted arrays of runs. The function assumes that the runs are sorted but does not check this.\n\n\n\n\n\n","category":"method"},{"location":"#Regions.invert-Tuple{Region}","page":"Home","title":"Regions.invert","text":"invert(x::Region)\n\nInvert a region. Inversion mirrors a region at the origin. A region is inverted by inverting each of its runs.\n\n\n\n\n\n","category":"method"},{"location":"#Regions.invert-Tuple{Run}","page":"Home","title":"Regions.invert","text":"invert(x::Run)\n\nInvert a run. Inversions mirrors a run at the origin. A run is inverted by negating  its row and inverting its columns.\n\nIn addition to the invert method, you can also use the unary - operator.\n\njulia> using Regions\n\njulia> invert(Run(1, 20:30))\nRun(-1, -30:-20)\n\njulia> -Run(-1, -30:-20)\nRun(1, 20:30)\n\n\n\n\n\n","category":"method"},{"location":"#Regions.invert-Tuple{UnitRange{Int64}}","page":"Home","title":"Regions.invert","text":"invert(x::UnitRange{Int64})\n\nInverts a range. Inversion mirrors a range at the origin. A range is  inverted by reversing and inverting each of its coordinates.\n\njulia> using Regions\n\njulia> invert(5:10)\n-10:-5\n\njulia> invert(invert(0:100))\n0:100\n\n\n\n\n\n","category":"method"},{"location":"#Regions.isclose-Tuple{Run, Run, Integer, Integer}","page":"Home","title":"Regions.isclose","text":"isclose(x::Run, y::Run, distance::Integer)\n\nTest if two runs are close.\n\nIf distance == 0 this is the same as isoverlapping(). If distance == 1 this is the same as istouching(). If distance > 1 this is testing of closeness.\n\n\n\n\n\n","category":"method"},{"location":"#Regions.isclose-Tuple{UnitRange{Int64}, UnitRange{Int64}, Integer}","page":"Home","title":"Regions.isclose","text":"isclose(::UnitRange{Int64}x, ::UnitRange{Int64}y, distance::Integer)\n\nTest if two ranges are close.\n\nIf distance == 0 this is the same as isoverlapping(). If distance == 1 this is the same as istouching(). If distance > 1 this is testing of closeness.\n\n\n\n\n\n","category":"method"},{"location":"#Regions.isoverlapping-Tuple{Run, Run}","page":"Home","title":"Regions.isoverlapping","text":"isoverlapping(x::Run, y::Run)\n\nTest if two runs overlap.\n\n\n\n\n\n","category":"method"},{"location":"#Regions.isoverlapping-Tuple{UnitRange{Int64}, UnitRange{Int64}}","page":"Home","title":"Regions.isoverlapping","text":"isoverlapping(x::UnitRange{Int64}, y::UnitRange{Int64})\n\nTest if two ranges overlap.\n\njulia> using Regions\n\njulia> isoverlapping(0:10, 5:15)\ntrue\n\njulia> isoverlapping(0:10, 20:30)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Regions.istouching-Tuple{Run, Run}","page":"Home","title":"Regions.istouching","text":"istouching(x::Run, y::Run)\n\nTest if two runs touch.\n\n\n\n\n\n","category":"method"},{"location":"#Regions.istouching-Tuple{UnitRange{Int64}, UnitRange{Int64}}","page":"Home","title":"Regions.istouching","text":"istouching(x::UnitRange{Int64}, y::UnitRange{Int64})\n\nTest if two ranges touch.\n\njulia> using Regions\n\njulia> istouching(0:10, 11:21)\ntrue\n\njulia> istouching(0:10, 12:22)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Regions.merge-Tuple{Vector{Run}, Vector{Run}}","page":"Home","title":"Regions.merge","text":"merge(a::Array{Run,1}, b::Array{Run,1})\n\nMerge sorted vectors a and b. Assumes that a and b are sorted  and does not check whether a or b are sorted. \n\n\n\n\n\n","category":"method"},{"location":"#Regions.minkowski_addition-Tuple{Region, Region}","page":"Home","title":"Regions.minkowski_addition","text":"minkowski_addition(a::Region, b::Region)\n\nMinkowski addition of a with structuring element b. Both the region a and the structuring element b are regions. The structuring element should be a region that is centered on the origin. This function partially supports complement regions  and uses DeMorgan's rules to eliminate the complement.    \n\n\n\n\n\n","category":"method"},{"location":"#Regions.minkowski_addition-Tuple{Run, Run}","page":"Home","title":"Regions.minkowski_addition","text":"minkowski_addition(x::Run, y::Run)\n\nMinkowski addition for two runs.\n\nThis is a building block for region-based morphology. It avoids touching each item of a range and calculates the result only by manipulating the range ends.\n\n\n\n\n\n","category":"method"},{"location":"#Regions.minkowski_addition-Tuple{Vector{Run}, Vector{Run}}","page":"Home","title":"Regions.minkowski_addition","text":"minkowski_addition(a::Array{Run,1}, b::Array{Run,1})\n\nMinkowski addition of two sorted arrays of runs. The function assumes that the runs are sorted but does not check this.\n\n\n\n\n\n","category":"method"},{"location":"#Regions.minkowski_subtraction-Tuple{Region, Region}","page":"Home","title":"Regions.minkowski_subtraction","text":"minkowski_subtraction(a::Region, b::Region)\n\nMinkowski subtraction of a with structuring element b. Both the region a and the structuring element b are regions. The structuring element should be a region that is centered on the origin. This function partially supports complement regions  and uses DeMorgan's rules to eliminate the complement.    \n\n\n\n\n\n","category":"method"},{"location":"#Regions.minkowski_subtraction-Tuple{Run, Run}","page":"Home","title":"Regions.minkowski_subtraction","text":"minkowski_subtraction(x::Run, y::Run)\n\nMinkowski subtraction for two runs.\n\nThis is a building block for region-based morphology. It avoids touching each item of a range and calculates the result only by manipulating the range ends.\n\n\n\n\n\n","category":"method"},{"location":"#Regions.minkowski_subtraction-Tuple{Vector{Run}, Vector{Run}}","page":"Home","title":"Regions.minkowski_subtraction","text":"minkowski_subtraction(a::Array{Run,1}, b::Array{Run,1})\n\nMinkowski subtraction of two sorted arrays of runs. The function assumes that the runs are sorted but does not check this.\n\n\n\n\n\n","category":"method"},{"location":"#Regions.morphgradient-Tuple{Region, Region}","page":"Home","title":"Regions.morphgradient","text":"morphgradient(a::Region, b::Region)\n\nThe morphological gradient is calculated by taking the difference of the dilated region  and the eroded region. The structuring element should be a region that is centered on the origin. \n\n\n\n\n\n","category":"method"},{"location":"#Regions.opening-Tuple{Region, Region}","page":"Home","title":"Regions.opening","text":"opening(a::Region, b::Region)\n\nOpening is implemented by an erosion followed by a minkowski addition. The structuring  element should be a region that is centered on the origin. Structures smaller than the structuring element are removed and the region boundaries are smoothed.\n\n\n\n\n\n","category":"method"},{"location":"#Regions.sort!-Tuple{Vector{Run}}","page":"Home","title":"Regions.sort!","text":"sort!(a::Array{Run, 1})\n\nSort the vector a in place. This ensures that runs are sorted after an operation that might  have destroyed the sort order, such as downsampling.\n\n\n\n\n\n","category":"method"},{"location":"#Regions.sort-Tuple{Vector{Run}}","page":"Home","title":"Regions.sort","text":"sort(a::Array{Run, 1})\n\nVariant of sort that returns a sorted copy of a leaving a itself unmodified. This ensures that runs are sorted after an operation that might have destroyed the sort order, such as  downsampling.\n\n\n\n\n\n","category":"method"},{"location":"#Regions.translate-Tuple{Region, Integer, Integer}","page":"Home","title":"Regions.translate","text":"translate(r::Region, x::Integer, y::Integer)\ntranslate(r::Region, a::Array{Int64, 1})\n\nTranslate a region. Translation moves a region. A region is translated by translating each  of it's runs. \n\n\n\n\n\n","category":"method"},{"location":"#Regions.translate-Tuple{Run, Integer, Integer}","page":"Home","title":"Regions.translate","text":"translate(r::Run, x::Integer, y::Integer)\ntranslate(r::Run, a::Array{Int64, 1})\n\nTranslate a run. Translation moves a run. A run is translated by adding offsets to its row and  columns.\n\nIn addition to the translate method, you can also use the + or - operators to translate a run.\n\njulia> using Regions\n\njulia> translate(Run(1, 20:30), 10, 20)\nRun(21, 30:40)\n\njulia> translate(Run(1, 2:3), [10, 20])\nRun(21, 12:13)\n\njulia> Run(1, 2:3) + [10, 20]\nRun(21, 12:13)\n\njulia> [1, 2] + Run(0, 0:10)\nRun(2, 1:11)\n\njulia> Run(0, 0:100) - [5, 25]\nRun(-25, -5:95)\n\n\n\n\n\n","category":"method"},{"location":"#Regions.translate-Tuple{UnitRange{Int64}, Integer}","page":"Home","title":"Regions.translate","text":"translate(x::UnitRange{Int64}, y::Integer)\n\nTranslate a range. Translation moves a range. A range is translated by adding  an offset to each of its coordinates.\n\nIn addition to the translate method, you can also use the + or - operators to translate a range.\n\njulia> using Regions\n\njulia> translate(0:10, 5)\n5:15\n\njulia> (5:15) + 10\n15:25\n\njulia> 10 + (5:15)\n15:25\n\njulia> (5:15) - 10\n-5:5\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"[Ghali]: Sherif Ghali, Introduction to Geometric Computing, Springer 2008","category":"page"}]
}

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Regions.jl</title><link rel="canonical" href="https://schrpe.github.io/Regions.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Regions.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Reference"><span>Reference</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/schrpe/Regions.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Regions"><a class="docs-heading-anchor" href="#Regions">Regions</a><a id="Regions-1"></a><a class="docs-heading-anchor-permalink" href="#Regions" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/schrpe/Regions.jl">Regions</a>.</p><p>Regions.jl defines a set of types and functions that model a discrete 2-dimensional region concept. </p><p><img src="region.svg" alt="Example of a region"/></p><p>In order to use the types and functions defined in the Regions package, you must first install it with the package manager and then make it known to your module:</p><pre><code class="language-none">julia&gt; using Pkg
julia&gt; using Pkg.add(path=&quot;D:/!julia/Regions&quot;)</code></pre><pre><code class="language-julia-repl">julia&gt; using Regions</code></pre><p>Regions can be used for various purposes in machine vision and image processing. Since they provide an efficient run-length encoding of binary images, they avoid the need to touch every pixel when doing binary morphology and thus enable substantial speedup of such operations. Regions are also the basis for binary blob analysis, where the calculation of shape-based features is also substantially accelerated because of the run-length encoding. Finally, regions can be used as the domain of image processing functions.</p><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>A region can be seen as a set of discrete coordinates in the cartesian plane. In fact, one of the main motivations for the region concept was to model a set of pixel locations for image processing purposes.</p><p>A region is represented with a sorted list of horizontal runs. Runs themselves are represented with a horizontal columns range and a vertical row coordinate.</p><p><img src="region_and_runs.svg" alt="Region and runs"/></p><p>Here is how this region can be created using the Julia REPL (assuming the origin (0, 0) is at the upper left):</p><pre><code class="language-julia-repl">julia&gt; Region([Run(0, 1:4), Run(1, 0:5), Run(2, 1:2), Run(2, 4:6), Run(3, 1:2), Run(3, 5:5), Run(4, 1:2), Run(4, 4:5), Run(5, 2:4)])
Region(Run[Run(0, 1:4), Run(1, 0:5), Run(2, 1:2), Run(2, 4:6), Run(3, 1:2), Run(3, 5:5), Run(4, 1:2), Run(4, 4:5), Run(5, 2:4)], false)</code></pre><h3 id="Range"><a class="docs-heading-anchor" href="#Range">Range</a><a id="Range-1"></a><a class="docs-heading-anchor-permalink" href="#Range" title="Permalink"></a></h3><p>The most basic building block of a region is a range. The <code>UnitRange{Int64}</code> is a suitable type and can be written like this:</p><pre><code class="language-julia-repl">julia&gt; 0:99
0:99

julia&gt; (0:99).start
0

julia&gt; (0:99).stop
99

julia&gt; length(0:99)
100

julia&gt; length(-50:50)
101</code></pre><p>A range where the stop is less than the start is considered empty.</p><pre><code class="language-julia-repl">julia&gt; isempty(0:0)
false

julia&gt; isempty(1:0)
true</code></pre><p>The natural sort order of ranges is to sort them by their start.</p><pre><code class="language-julia-repl">julia&gt; 0:100 &lt; 1:101
true

julia&gt; 0:1 &lt; 1:100
true

julia&gt; 0:50 &lt; 0:100
true

julia&gt; isless(0:100, 1:101)
true</code></pre><p>Inversion mirrors a range at the origin.</p><pre><code class="language-julia-repl">julia&gt; invert(0:100)
-100:0

julia&gt; invert(invert(5:10))
5:10</code></pre><p>Translation moves a range by an offset.</p><pre><code class="language-julia-repl">julia&gt; translate(0:100, 50)
50:150

julia&gt; (10:20) + 30
40:50

julia&gt; 10 + (20:30)
30:40

julia&gt; (50:100) - 10
40:90</code></pre><p>You can check whether a value is contained in a range.</p><pre><code class="language-julia-repl">julia&gt; contains(10:20, 10)
true

julia&gt; contains(10:20, 15)
true

julia&gt; contains(10:20, 20)
true

julia&gt; contains(10:20, 9)
false

julia&gt; 14 ∈ 10:20
true</code></pre><p>Two ranges can overlap or touch.</p><pre><code class="language-julia-repl">julia&gt; isoverlapping(10:20, 5:25)
true

julia&gt; isoverlapping(0:0, 1:1)
false

julia&gt; istouching(0:0, 1:1)
true

julia&gt; istouching(0:0, 2:2)
false</code></pre><h3 id="Run"><a class="docs-heading-anchor" href="#Run">Run</a><a id="Run-1"></a><a class="docs-heading-anchor-permalink" href="#Run" title="Permalink"></a></h3><p>A run combines a vertical row coordinate with a range of horizontal columns coordinates.</p><p>An empty run is a run whose columns range is empty.</p><pre><code class="language-julia-repl">julia&gt; isempty(Run(0, 0:-1))
true

julia&gt; isempty(Run(0, 0:100))
false</code></pre><p>The natural sort order of runs is to sort them by their row, then by their columns range.</p><pre><code class="language-julia-repl">julia&gt; Run(0, 0:100) &lt; Run(1, 0:100)
true

julia&gt; Run(0, 0:100) &lt; Run(0, 1:101)
true</code></pre><p>Inversion mirrors a run at the origin.</p><pre><code class="language-julia-repl">julia&gt; invert(Run(10, 50:100))
Run(-10, -100:-50)

julia&gt; invert(invert(Run(1, 5:10)))
Run(1, 5:10)</code></pre><p>Translation moves a run by horizontal and vertical offsets.</p><pre><code class="language-julia-repl">julia&gt; translate(Run(0, 0:100), 10, 20)
Run(20, 10:110)

julia&gt; Run(0, 10:20) + [30, 40]
Run(40, 40:50)

julia&gt; Run(0, 10:20) - [30, 40]
Run(-40, -20:-10)</code></pre><h3 id="Region"><a class="docs-heading-anchor" href="#Region">Region</a><a id="Region-1"></a><a class="docs-heading-anchor-permalink" href="#Region" title="Permalink"></a></h3><p>A region is a subset of the discrete two-dimensional space. It represents a set (in the sense of mathematical set theory) of discrete coordinates. A region may be finite or infinite. A region may not be connected and it may contain holes.</p><p>Regions are an essential concept in computer vision and are useful in many respects.</p><p>Regions are not necessarily related to images; they can exist independently and without images. In addition, the coordinate space is not confined to the bounds of an image, and regions can extend into the quadrants with negative coordinates in the two-dimensional space.</p><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Regions">Regions</a></li><ul><li><a href="#Introduction">Introduction</a></li><li><a href="#Contents">Contents</a></li><li><a href="#Reference">Reference</a></li><li><a href="#Index">Index</a></li></ul></ul><h2 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Regions.Regions" href="#Regions.Regions"><code>Regions.Regions</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">Regions</code></pre><p>Main module for Regions.jl - a set of types that model a discrete  2-dimensional region concept.</p><p><strong>Exports</strong></p><ul><li>Run   </li><li>Region</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.Region" href="#Regions.Region"><code>Regions.Region</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Region</code></pre><p>A region is a discrete set of coordinates in two-dimensional euclidean space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L353-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.Run" href="#Regions.Run"><code>Regions.Run</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Run</code></pre><p>A run is a (possibly partial) set of consecutive coordinates within a row of a  region. It consists of a discrete row coordinate (of type Signed) and a range  of discrete column coordinates (of type UnitRange{Int64}).</p><p>Runs specify a sort order: one run is smaller than the other if it starts before the other run modeling the coordinates from left to right and top to  bottom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L157-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{Region, Region}" href="#Base.:==-Tuple{Region, Region}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">==(a::Region, b::Region)</code></pre><p>Equality operator for two regions. Two regions are equal, if both their runs and their  complement flags are equal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L365-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.contains-Tuple{Region, Integer, Integer}" href="#Base.contains-Tuple{Region, Integer, Integer}"><code>Base.contains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contains(r::Region, x::Integer, y::Integer)
contains(r::Region, a::Array{Int64, 1})</code></pre><p>Test if region r contains position (x, y).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L417-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.contains-Tuple{Run, Integer, Integer}" href="#Base.contains-Tuple{Run, Integer, Integer}"><code>Base.contains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contains(r::Run, x::Integer, y::Integer)
contains(r::Run, a::Array{Int64, 1})</code></pre><p>Test if run r contains position (x, y).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L267-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.contains-Tuple{UnitRange{Int64}, Integer}" href="#Base.contains-Tuple{UnitRange{Int64}, Integer}"><code>Base.contains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contains(x::UnitRange{Int64}, y::Integer)</code></pre><p>Test if range x contains value x.</p><p>In addition to the contains method, you can also use the ∈ operator.</p><pre><code class="language-julia-repl">julia&gt; using Regions

julia&gt; contains(0:10, 5)
true

julia&gt; contains(0:10, 15)
false

julia&gt; 0 ∈ 0:10
true

julia&gt; 100 ∈ 0:10
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L74-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Tuple{Region}" href="#Base.copy-Tuple{Region}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">copy(x::Region)</code></pre><p>Create a copy of a region.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L373-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty-Tuple{Run}" href="#Base.isempty-Tuple{Run}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isempty(x::Run)</code></pre><p>Discover whether the run is empty.</p><pre><code class="language-julia-repl">julia&gt; using Regions

julia&gt; isempty(Run(1, 1:10))
false

julia&gt; isempty(Run(2, 1:1))
false

julia&gt; isempty(Run(3, 1:0))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L173-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isless-Tuple{Run, Run}" href="#Base.isless-Tuple{Run, Run}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isless(x::Run, y::Run)</code></pre><p>Compare two runs according to their natural sort order. First, their rows are compared, and if they are equal, their column ranges are compared.</p><pre><code class="language-julia-repl">julia&gt; using Regions

julia&gt; isless(Run(0, 1:10), Run(1, 0:10))
true

julia&gt; isless(Run(1, 1:10), Run(1, 2:10))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L193-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.union-Tuple{Region, Region}" href="#Base.union-Tuple{Region, Region}"><code>Base.union</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">union(a::Region, b::Region)</code></pre><p>Calculates the union of two regions. This function supports complement regions and uses  DeMorgan&#39;s rules to eliminate the complement.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L572-L577">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.union-Tuple{Vector{Run}, Vector{Run}}" href="#Base.union-Tuple{Vector{Run}, Vector{Run}}"><code>Base.union</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">union(a::Array{Run,1}, b::Array{Run,1})</code></pre><p>Calculates the union of two sorted arrays of runs. The function assumes that the runs are sorted but does not check this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L560-L565">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.closing-Tuple{Region, Region}" href="#Regions.closing-Tuple{Region, Region}"><code>Regions.closing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">closing(a::Region, b::Region)</code></pre><p>Closing is implemented by a dilation followed by a minkowski subtraction. The structuring  element should be a region that is centered on the origin. Gaps and holes smaller than the structuring element are closed and the region boundaries are smoothed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L893-L899">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.complement-Tuple{Region}" href="#Regions.complement-Tuple{Region}"><code>Regions.complement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">complement(x::Region)</code></pre><p>Calculates the set-theoretic complement of a region.   </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L485-L489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.difference-Tuple{Region, Region}" href="#Regions.difference-Tuple{Region, Region}"><code>Regions.difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">difference(a::Region, b::Region)</code></pre><p>Calculates the union of two regions. This function supports complement regions and uses  DeMorgan&#39;s rules to eliminate the complement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L712-L717">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.difference-Tuple{Vector{Run}, Vector{Run}}" href="#Regions.difference-Tuple{Vector{Run}, Vector{Run}}"><code>Regions.difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">difference(a::Array{Run,1}, b::Array{Run,1})</code></pre><p>Calculates the difference of two sorted arrays of runs. The function assumes that the runs are sorted but does not check this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L649-L654">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.dilation-Tuple{Region, Region}" href="#Regions.dilation-Tuple{Region, Region}"><code>Regions.dilation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dilation(a::Region, b::Region)</code></pre><p>Dilation of a with structuring element b. Both the region a and the structuring element b are regions. The structuring element should be a region that is centered on the origin. This function partially supports complement regions  and uses DeMorgan&#39;s rules to eliminate the complement.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L842-L849">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.dilation-Tuple{Vector{Run}, Vector{Run}}" href="#Regions.dilation-Tuple{Vector{Run}, Vector{Run}}"><code>Regions.dilation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dilation(a::Array{Run,1}, b::Array{Run,1})</code></pre><p>Dilation of a with structuring element b. The function assumes that the runs are sorted but does not check this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L786-L791">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.erosion-Tuple{Region, Region}" href="#Regions.erosion-Tuple{Region, Region}"><code>Regions.erosion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">erosion(a::Region, b::Region)</code></pre><p>Erosion of a with structuring element b. Both the region a and the structuring element b are regions. The structuring element should be a region that is centered on the origin. This function partially supports complement regions  and uses DeMorgan&#39;s rules to eliminate the complement.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L862-L869">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.erosion-Tuple{Vector{Run}, Vector{Run}}" href="#Regions.erosion-Tuple{Vector{Run}, Vector{Run}}"><code>Regions.erosion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">erosion(a::Array{Run,1}, b::Array{Run,1})</code></pre><p>Erosion of a with structuring element b. The function assumes that the runs are sorted but does not check this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L794-L799">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.intersection-Tuple{Region, Region}" href="#Regions.intersection-Tuple{Region, Region}"><code>Regions.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersection(a::Region, b::Region)</code></pre><p>Calculates the intersection of two regions. This function supports complement regions and uses  DeMorgan&#39;s rules to eliminate the complement.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L631-L636">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.intersection-Tuple{Vector{Run}, Vector{Run}}" href="#Regions.intersection-Tuple{Vector{Run}, Vector{Run}}"><code>Regions.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersection(a::Array{Run,1}, b::Array{Run,1})</code></pre><p>Calculates the intersection of two sorted arrays of runs. The function assumes that the runs are sorted but does not check this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L619-L624">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.invert-Tuple{Region}" href="#Regions.invert-Tuple{Region}"><code>Regions.invert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">invert(x::Region)</code></pre><p>Invert a region. Inversion mirrors a region at the origin. A region is inverted by inverting each of its runs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L380-L385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.invert-Tuple{Run}" href="#Regions.invert-Tuple{Run}"><code>Regions.invert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">invert(x::Run)</code></pre><p>Invert a run. Inversions mirrors a run at the origin. A run is inverted by negating  its row and inverting its columns.</p><p>In addition to the invert method, you can also use the unary - operator.</p><pre><code class="language-julia-repl">julia&gt; using Regions

julia&gt; invert(Run(1, 20:30))
Run(-1, -30:-20)

julia&gt; -Run(-1, -30:-20)
Run(1, 20:30)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L211-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.invert-Tuple{UnitRange{Int64}}" href="#Regions.invert-Tuple{UnitRange{Int64}}"><code>Regions.invert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">invert(x::UnitRange{Int64})</code></pre><p>Inverts a range. Inversion mirrors a range at the origin. A range is  inverted by reversing and inverting each of its coordinates.</p><pre><code class="language-julia-repl">julia&gt; using Regions

julia&gt; invert(5:10)
-10:-5

julia&gt; invert(invert(0:100))
0:100</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L26-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.isclose-Tuple{Run, Run, Integer, Integer}" href="#Regions.isclose-Tuple{Run, Run, Integer, Integer}"><code>Regions.isclose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isclose(x::Run, y::Run, distance::Integer)</code></pre><p>Test if two runs are close.</p><p>If distance == 0 this is the same as isoverlapping(). If distance == 1 this is the same as istouching(). If distance &gt; 1 this is testing of closeness.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L291-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.isclose-Tuple{UnitRange{Int64}, UnitRange{Int64}, Integer}" href="#Regions.isclose-Tuple{UnitRange{Int64}, UnitRange{Int64}, Integer}"><code>Regions.isclose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isclose(::UnitRange{Int64}x, ::UnitRange{Int64}y, distance::Integer)</code></pre><p>Test if two ranges are close.</p><p>If distance == 0 this is the same as isoverlapping(). If distance == 1 this is the same as istouching(). If distance &gt; 1 this is testing of closeness.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L133-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.isoverlapping-Tuple{Run, Run}" href="#Regions.isoverlapping-Tuple{Run, Run}"><code>Regions.isoverlapping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isoverlapping(x::Run, y::Run)</code></pre><p>Test if two runs overlap.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L277-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.isoverlapping-Tuple{UnitRange{Int64}, UnitRange{Int64}}" href="#Regions.isoverlapping-Tuple{UnitRange{Int64}, UnitRange{Int64}}"><code>Regions.isoverlapping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isoverlapping(x::UnitRange{Int64}, y::UnitRange{Int64})</code></pre><p>Test if two ranges overlap.</p><pre><code class="language-julia-repl">julia&gt; using Regions

julia&gt; isoverlapping(0:10, 5:15)
true

julia&gt; isoverlapping(0:10, 20:30)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L99-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.istouching-Tuple{Run, Run}" href="#Regions.istouching-Tuple{Run, Run}"><code>Regions.istouching</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">istouching(x::Run, y::Run)</code></pre><p>Test if two runs touch.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L284-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.istouching-Tuple{UnitRange{Int64}, UnitRange{Int64}}" href="#Regions.istouching-Tuple{UnitRange{Int64}, UnitRange{Int64}}"><code>Regions.istouching</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">istouching(x::UnitRange{Int64}, y::UnitRange{Int64})</code></pre><p>Test if two ranges touch.</p><pre><code class="language-julia-repl">julia&gt; using Regions

julia&gt; istouching(0:10, 11:21)
true

julia&gt; istouching(0:10, 12:22)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L116-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.merge-Tuple{Vector{Run}, Vector{Run}}" href="#Regions.merge-Tuple{Vector{Run}, Vector{Run}}"><code>Regions.merge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">merge(a::Array{Run,1}, b::Array{Run,1})</code></pre><p>Merge sorted vectors <code>a</code> and <code>b</code>. Assumes that <code>a</code> and <code>b</code> are sorted  and does not check whether <code>a</code> or <code>b</code> are sorted. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L492-L497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.minkowski_addition-Tuple{Region, Region}" href="#Regions.minkowski_addition-Tuple{Region, Region}"><code>Regions.minkowski_addition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minkowski_addition(a::Region, b::Region)</code></pre><p>Minkowski addition of a with structuring element b. Both the region a and the structuring element b are regions. The structuring element should be a region that is centered on the origin. This function partially supports complement regions  and uses DeMorgan&#39;s rules to eliminate the complement.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L802-L809">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.minkowski_addition-Tuple{Run, Run}" href="#Regions.minkowski_addition-Tuple{Run, Run}"><code>Regions.minkowski_addition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minkowski_addition(x::Run, y::Run)</code></pre><p>Minkowski addition for two runs.</p><p>This is a building block for region-based morphology. It avoids touching each item of a range and calculates the result only by manipulating the range ends.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L303-L311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.minkowski_addition-Tuple{Vector{Run}, Vector{Run}}" href="#Regions.minkowski_addition-Tuple{Vector{Run}, Vector{Run}}"><code>Regions.minkowski_addition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minkowski_addition(a::Array{Run,1}, b::Array{Run,1})</code></pre><p>Minkowski addition of two sorted arrays of runs. The function assumes that the runs are sorted but does not check this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L730-L735">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.minkowski_subtraction-Tuple{Region, Region}" href="#Regions.minkowski_subtraction-Tuple{Region, Region}"><code>Regions.minkowski_subtraction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minkowski_subtraction(a::Region, b::Region)</code></pre><p>Minkowski subtraction of a with structuring element b. Both the region a and the structuring element b are regions. The structuring element should be a region that is centered on the origin. This function partially supports complement regions  and uses DeMorgan&#39;s rules to eliminate the complement.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L822-L829">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.minkowski_subtraction-Tuple{Run, Run}" href="#Regions.minkowski_subtraction-Tuple{Run, Run}"><code>Regions.minkowski_subtraction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minkowski_subtraction(x::Run, y::Run)</code></pre><p>Minkowski subtraction for two runs.</p><p>This is a building block for region-based morphology. It avoids touching each item of a range and calculates the result only by manipulating the range ends.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L314-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.minkowski_subtraction-Tuple{Vector{Run}, Vector{Run}}" href="#Regions.minkowski_subtraction-Tuple{Vector{Run}, Vector{Run}}"><code>Regions.minkowski_subtraction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minkowski_subtraction(a::Array{Run,1}, b::Array{Run,1})</code></pre><p>Minkowski subtraction of two sorted arrays of runs. The function assumes that the runs are sorted but does not check this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L758-L763">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.morphgradient-Tuple{Region, Region}" href="#Regions.morphgradient-Tuple{Region, Region}"><code>Regions.morphgradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">morphgradient(a::Region, b::Region)</code></pre><p>The morphological gradient is calculated by taking the difference of the dilated region  and the eroded region. The structuring element should be a region that is centered on the origin. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L904-L909">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.opening-Tuple{Region, Region}" href="#Regions.opening-Tuple{Region, Region}"><code>Regions.opening</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">opening(a::Region, b::Region)</code></pre><p>Opening is implemented by an erosion followed by a minkowski addition. The structuring  element should be a region that is centered on the origin. Structures smaller than the structuring element are removed and the region boundaries are smoothed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L882-L888">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.sort!-Tuple{Vector{Run}}" href="#Regions.sort!-Tuple{Vector{Run}}"><code>Regions.sort!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sort!(a::Array{Run, 1})</code></pre><p>Sort the vector a in place. This ensures that runs are sorted after an operation that might  have destroyed the sort order, such as downsampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L535-L540">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.sort-Tuple{Vector{Run}}" href="#Regions.sort-Tuple{Vector{Run}}"><code>Regions.sort</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sort(a::Array{Run, 1})</code></pre><p>Variant of sort that returns a sorted copy of a leaving a itself unmodified. This ensures that runs are sorted after an operation that might have destroyed the sort order, such as  downsampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L525-L531">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.translate-Tuple{Region, Integer, Integer}" href="#Regions.translate-Tuple{Region, Integer, Integer}"><code>Regions.translate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">translate(r::Region, x::Integer, y::Integer)
translate(r::Region, a::Array{Int64, 1})</code></pre><p>Translate a region. Translation moves a region. A region is translated by translating each  of it&#39;s runs. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L396-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.translate-Tuple{Run, Integer, Integer}" href="#Regions.translate-Tuple{Run, Integer, Integer}"><code>Regions.translate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">translate(r::Run, x::Integer, y::Integer)
translate(r::Run, a::Array{Int64, 1})</code></pre><p>Translate a run. Translation moves a run. A run is translated by adding offsets to its row and  columns.</p><p>In addition to the translate method, you can also use the + or - operators to translate a run.</p><pre><code class="language-julia-repl">julia&gt; using Regions

julia&gt; translate(Run(1, 20:30), 10, 20)
Run(21, 30:40)

julia&gt; translate(Run(1, 2:3), [10, 20])
Run(21, 12:13)

julia&gt; Run(1, 2:3) + [10, 20]
Run(21, 12:13)

julia&gt; [1, 2] + Run(0, 0:10)
Run(2, 1:11)

julia&gt; Run(0, 0:100) - [5, 25]
Run(-25, -5:95)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L232-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Regions.translate-Tuple{UnitRange{Int64}, Integer}" href="#Regions.translate-Tuple{UnitRange{Int64}, Integer}"><code>Regions.translate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">translate(x::UnitRange{Int64}, y::Integer)</code></pre><p>Translate a range. Translation moves a range. A range is translated by adding  an offset to each of its coordinates.</p><p>In addition to the translate method, you can also use the + or - operators to translate a range.</p><pre><code class="language-julia-repl">julia&gt; using Regions

julia&gt; translate(0:10, 5)
5:15

julia&gt; (5:15) + 10
15:25

julia&gt; 10 + (5:15)
15:25

julia&gt; (5:15) - 10
-5:5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schrpe/Regions.jl/blob/3a204bb419683bf85610d57007715e04eaa3d825/src/Regions.jl#L44-L68">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Regions.Regions"><code>Regions.Regions</code></a></li><li><a href="#Regions.Region"><code>Regions.Region</code></a></li><li><a href="#Regions.Run"><code>Regions.Run</code></a></li><li><a href="#Base.:==-Tuple{Region, Region}"><code>Base.:==</code></a></li><li><a href="#Base.contains-Tuple{Run, Integer, Integer}"><code>Base.contains</code></a></li><li><a href="#Base.contains-Tuple{UnitRange{Int64}, Integer}"><code>Base.contains</code></a></li><li><a href="#Base.contains-Tuple{Region, Integer, Integer}"><code>Base.contains</code></a></li><li><a href="#Base.copy-Tuple{Region}"><code>Base.copy</code></a></li><li><a href="#Base.isempty-Tuple{Run}"><code>Base.isempty</code></a></li><li><a href="#Base.isless-Tuple{Run, Run}"><code>Base.isless</code></a></li><li><a href="#Base.union-Tuple{Vector{Run}, Vector{Run}}"><code>Base.union</code></a></li><li><a href="#Base.union-Tuple{Region, Region}"><code>Base.union</code></a></li><li><a href="#Regions.closing-Tuple{Region, Region}"><code>Regions.closing</code></a></li><li><a href="#Regions.complement-Tuple{Region}"><code>Regions.complement</code></a></li><li><a href="#Regions.difference-Tuple{Region, Region}"><code>Regions.difference</code></a></li><li><a href="#Regions.difference-Tuple{Vector{Run}, Vector{Run}}"><code>Regions.difference</code></a></li><li><a href="#Regions.dilation-Tuple{Vector{Run}, Vector{Run}}"><code>Regions.dilation</code></a></li><li><a href="#Regions.dilation-Tuple{Region, Region}"><code>Regions.dilation</code></a></li><li><a href="#Regions.erosion-Tuple{Region, Region}"><code>Regions.erosion</code></a></li><li><a href="#Regions.erosion-Tuple{Vector{Run}, Vector{Run}}"><code>Regions.erosion</code></a></li><li><a href="#Regions.intersection-Tuple{Region, Region}"><code>Regions.intersection</code></a></li><li><a href="#Regions.intersection-Tuple{Vector{Run}, Vector{Run}}"><code>Regions.intersection</code></a></li><li><a href="#Regions.invert-Tuple{Run}"><code>Regions.invert</code></a></li><li><a href="#Regions.invert-Tuple{UnitRange{Int64}}"><code>Regions.invert</code></a></li><li><a href="#Regions.invert-Tuple{Region}"><code>Regions.invert</code></a></li><li><a href="#Regions.isclose-Tuple{UnitRange{Int64}, UnitRange{Int64}, Integer}"><code>Regions.isclose</code></a></li><li><a href="#Regions.isclose-Tuple{Run, Run, Integer, Integer}"><code>Regions.isclose</code></a></li><li><a href="#Regions.isoverlapping-Tuple{Run, Run}"><code>Regions.isoverlapping</code></a></li><li><a href="#Regions.isoverlapping-Tuple{UnitRange{Int64}, UnitRange{Int64}}"><code>Regions.isoverlapping</code></a></li><li><a href="#Regions.istouching-Tuple{UnitRange{Int64}, UnitRange{Int64}}"><code>Regions.istouching</code></a></li><li><a href="#Regions.istouching-Tuple{Run, Run}"><code>Regions.istouching</code></a></li><li><a href="#Regions.merge-Tuple{Vector{Run}, Vector{Run}}"><code>Regions.merge</code></a></li><li><a href="#Regions.minkowski_addition-Tuple{Region, Region}"><code>Regions.minkowski_addition</code></a></li><li><a href="#Regions.minkowski_addition-Tuple{Vector{Run}, Vector{Run}}"><code>Regions.minkowski_addition</code></a></li><li><a href="#Regions.minkowski_addition-Tuple{Run, Run}"><code>Regions.minkowski_addition</code></a></li><li><a href="#Regions.minkowski_subtraction-Tuple{Run, Run}"><code>Regions.minkowski_subtraction</code></a></li><li><a href="#Regions.minkowski_subtraction-Tuple{Vector{Run}, Vector{Run}}"><code>Regions.minkowski_subtraction</code></a></li><li><a href="#Regions.minkowski_subtraction-Tuple{Region, Region}"><code>Regions.minkowski_subtraction</code></a></li><li><a href="#Regions.morphgradient-Tuple{Region, Region}"><code>Regions.morphgradient</code></a></li><li><a href="#Regions.opening-Tuple{Region, Region}"><code>Regions.opening</code></a></li><li><a href="#Regions.sort-Tuple{Vector{Run}}"><code>Regions.sort</code></a></li><li><a href="#Regions.sort!-Tuple{Vector{Run}}"><code>Regions.sort!</code></a></li><li><a href="#Regions.translate-Tuple{Run, Integer, Integer}"><code>Regions.translate</code></a></li><li><a href="#Regions.translate-Tuple{UnitRange{Int64}, Integer}"><code>Regions.translate</code></a></li><li><a href="#Regions.translate-Tuple{Region, Integer, Integer}"><code>Regions.translate</code></a></li></ul><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Ghali"><a class="tag is-link" href="#citeref-Ghali">Ghali</a>Sherif Ghali, Introduction to Geometric Computing, Springer 2008</li></ul></section></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 11 May 2021 15:53">Tuesday 11 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
